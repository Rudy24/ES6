一 let  命令
1.基本用法
let 用来声明变量，类似var，但是声明的变量只在let命令所在代码块内有效

 {
 	let a = 1;
 	var b = 1;
 }

 a //a is not defined
 b //1

 for (let i = 0; i < 10; i++) {console.log(i)};

 console.log(i); // i is not defined

 上面代码中 计数器i只在for循环体内有效，在循环外引用就会报错

 var a = [];

 for (var i = 0; i < 10; i++) {
 	a[i] = function() {
 		console.log(i);
 	}
 }

 a[6](); // 10;

 var a = [];

 for (let i = 0; i < 10; i++) {
 	a[i] = function() {
 		console.log(i);
 	};
 }

 a[6]();// 6;

另外，for循环还有一个特别之处，就是循环语句部分是一个父作用域，
而循环体内部是一个单独的子作用域。
 for (let i = 0; i < 3; i++) {
 	let i = 'abc';
 	console.log(i);
 }

 //abc
 //abc
 //abc

 上面代码输出了3次abc，这表明函数内部的变量i和外部的变量i是分离的

 2.不存在变量提升
 var 命令会发生'变量提升'现象，即变量可以在声明之前使用，但值为undefined，
 但是let纠正了这种现象，改变了语法，如果在声明变量之前使用就是报错

 //var 的情况
 console.log(foo); //undefined
 var foo = 2; // ===> 它先声明var foo; 然后foo = 2;

 //let的情况
 console.log(bar); //报错 ReferenceError: bar is not defined
 let bar = 2;

 3.暂时性死区
 只要块级作用域内存在let命令，它所声明的变量就'绑定'这个区域了，
 不再受外部的影响

 var tmp = 123;
 if (true) {
 	tmp = 'abc'; 
 	let tmp;
 }

 上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，
 导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。
 ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，
 从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。
总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，
称为“暂时性死区”（temporal dead zone，简称 TDZ）。

if (true) {
  // TDZ开始
  tmp = 'abc'; // ReferenceError
  console.log(tmp); // ReferenceError

  let tmp; // TDZ结束
  console.log(tmp); // undefined

  tmp = 123;
  console.log(tmp); // 123
}

“暂时性死区”也意味着typeof不再是一个百分之百安全的操作。

typeof x; // ReferenceError
let x;

有些“死区”比较隐蔽，不太容易发现。

function bar2(x=y,y=2) {
	return [x,y];
}

bar2(); //ReferenceError: y is not defined

上面代码中，调用bar函数之所以报错（某些实现可能不报错），
是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于”死区“。
如果y的默认值是x，就不会报错，因为此时x已经声明了。

function bar(x = 2, y = x) {
  return [x, y];
}
bar(); // [2, 2]

另外，下面的代码也会报错，与var的行为不同。

// 不报错
var x = x;

// 报错
let x = x;
// ReferenceError: x is not defined

上面代码报错，也是因为暂时性死区。使用let声明变量时，
只要变量在还没有声明完成前使用，就会报错。上面这行就属于这个情况，
在变量x的声明语句还没有执行完成前，就去取x的值，导致报错”x 未定义“。


总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，
但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。

4.不允许重复声明
let不允许在'相同作用域内'，重复声明同一个变量。

// 报错
function () {
  let a = 10;
  var a = 1;
}

// 报错
function () {
  let a = 10;
  let a = 1;
}

因此，不能在函数内部重新声明参数。

function func(arg) {
  let arg; 
}

func(); //Identifier 'arg' has already been declared

function func(arg) {
  {
    let arg; // 不报错
  }
}
二 块级作用域
5.为什么需要块级作用域？
ES5只有全局和函数作用域 没有块级作用域 这会带来很多不合理的场景
(1) 内层变量可能覆盖外层变量
	var tmp = new Date();
	function f() {
		console.log(tmp);
		if (false) {
			var tmp = 'hello world';
		}
	}

	f(); //undefined
上面代码的原意是，if代码块的外部使用外层的tmp变量，
内部使用内层的tmp变量。但是，函数f执行后，输出结果为undefined，
原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。


(2)用来计数的循环变量泄露为全局变量

var s = 'hello';

for (var i = 0; i < s.length; i++) {
  console.log(s[i]);
}

console.log(i); // h e l l o 5

上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。

2.ES6的块级作用域
let实际上为Javascript 新增了块级作用域

function f1() {
  let n = 5;
  if (true) {
    let n = 10;
  }
  console.log(n); // 5
}

上面的函数有两个代码块，都声明了变量n，运行后输出5。
这表示外层代码块不受内层代码块的影响。如果使用var定义变量n，最后输出的值就是10。

3.块级作用域与函数声明

函数能不能在块级作用域之中声明？这是一个相当令人混淆的问题。

ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。

// 情况一
if (true) {
  function f() {}
}

// 情况二
try {
  function f() {}
} catch(e) {
  // ...
}

上面两种函数声明，根据 ES5 的规定都是非法的。

但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。

ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。

考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。
如果确实需要，也应该写成函数表达式，而不是函数声明语句。

// 函数声明语句
{
  let a = 'secret';
  function f() {
    return a;
  }
}

// 函数表达式
{
  let a = 'secret';
  let f = function () {
    return a;
  };
}

另外，还有一个需要注意的地方。ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。

// 不报错
'use strict';
if (true) {
  function f() {}
}

// 报错 In strict mode code, functions can only be declared at top level or inside a block.
'use strict';
if (true)
  function f() {}


三 do 表达式

本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。

{
  let t = f();
  t = t * t + 1;
}

上面代码中，块级作用域将两个语句封装在一起。但是，在块级作用域以外，
没有办法得到t的值，因为块级作用域不返回值，除非t是全局变量。

现在有一个提案，使得块级作用域可以变为表达式，也就是说可以返回值，
办法就是在块级作用域之前加上do，使它变为do表达式。

let x = do {
  let t = f();
  t * t + 1;
};

上面代码中，变量x会得到整个块级作用域的返回值。

四 const 命令
1.基本用法
const声明一个只读的'常量'。一旦声明，常量的值就不能改变。

const PI = 3.1415;
PI // 3.1415

PI = 3;
// TypeError: Assignment to constant variable.

const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。

const A;
//Uncaught SyntaxError: Missing initializer in const declaration
上面代码表示，对于const来说，只声明不赋值，就会报错。

const的作用域与let命令相同：只在声明所在的块级作用域内有效。

if (true) {
  const MAX = 5;
}

MAX // Uncaught ReferenceError: MAX is not defined

const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。

if (true) {
	console.log(Max);  //Uncaught ReferenceError: Max is not defined
	const Max = 4;
}

const声明的常量，也与let一样不可重复声明。

var message = "Hello!";
let age = 25;

// 以下两行都会报错
const message = "Goodbye!";
const age = 30;

本质
const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。
对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。
但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，
const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。
因此，将一个对象声明为常量必须非常小心。

const foo = {};

// 为 foo 添加一个属性，可以成功
foo.prop = 123;
foo.prop // 123

// 将 foo 指向另一个对象，就会报错
foo = {}; // TypeError: "foo" is read-only

上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，
即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。


ES6 声明变量的六种方法

ES5 只有两种声明变量的方法：var命令和function命令。ES6除了添加let和const命令，
后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有6种声明变量的方法。

五 顶层对象的属性

顶层对象，在浏览器环境指的是window对象，在Node指的是global对象。
ES5之中，顶层对象的属性与全局变量是等价的。

window.a = 1;
a // 1

a = 2;
window.a // 2

顶层对象的属性与全局变量挂钩，被认为是JavaScript语言最大的设计败笔之一。
这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，
只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；
其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；
最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。
另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。

ES6为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，
依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，
不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。

var a = 1;
// 如果在Node的REPL环境，可以写成global.a
// 或者采用通用方法，写成this.a
window.a // 1

let b = 1;
window.b // undefined

上面代码中，全局变量a由var命令声明，所以它是顶层对象的属性；
全局变量b由let命令声明，所以它不是顶层对象的属性，返回undefined。


